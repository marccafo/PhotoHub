@page "/"
@using PhotoHub.Blazor.Shared.Services
@using PhotoHub.Blazor.Shared.Models
@using MudBlazor
@inject IAssetService AssetService
@inject ISnackbar Snackbar
@inject NavigationManager Navigation
@inject IJSRuntime JS
@implements IDisposable

<PageTitle>Timeline - PhotoHub</PageTitle>

@if (_loading)
{
    <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="my-4" />
}

<div class="timeline-wrapper">
    <div class="timeline-main-container">
        <div class="timeline-content-wrapper">
            @if (_pendingAssetsCount > 0 && !_syncingAll)
            {
                <div class="sync-alert-container">
                    <MudAlert Severity="Severity.Info" 
                              Variant="Variant.Filled" 
                              Class="sync-alert"
                              Dense="true"
                              Icon="@Icons.Material.Filled.CloudUpload">
                        <div class="d-flex align-center justify-space-between gap-3">
                            <div class="flex-grow-1 min-width-0">
                                <MudText Typo="Typo.body1" Class="mb-1">
                                    <strong>@_pendingAssetsCount</strong> @(_pendingAssetsCount == 1 ? "foto pendiente" : "fotos pendientes") de sincronizar
                                </MudText>
                                <MudText Typo="Typo.body2" Style="opacity: 0.8;">
                                    Se copiarán al directorio interno para su indexación
                                </MudText>
                            </div>
                            <MudButton Variant="Variant.Text" 
                                       Color="Color.Inherit" 
                                       StartIcon="@Icons.Material.Filled.CloudUpload"
                                       OnClick="SyncAllPendingAssets"
                                       Disabled="@_syncingAll"
                                       Class="flex-shrink-0">
                                Sincronizar Todas
                            </MudButton>
                        </div>
                    </MudAlert>
                </div>
            }

            @if (_syncingAll)
            {
                <div class="sync-alert-container">
                    <MudAlert Severity="Severity.Info" 
                              Variant="Variant.Filled" 
                              Class="sync-alert"
                              Dense="true"
                              Icon="@Icons.Material.Filled.CloudSync">
                        <div class="d-flex align-center gap-3">
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="flex-shrink-0" />
                            <div class="flex-grow-1 min-width-0">
                                <MudText Typo="Typo.body2" Class="mb-1">@_syncProgressMessage</MudText>
                                <MudProgressLinear Color="Color.Primary" Value="@_syncProgress" Class="my-2" />
                                <MudText Typo="Typo.caption" Style="opacity: 0.8;">
                                    @_syncCurrent de @_syncTotal sincronizadas 
                                    @if (_syncSuccessful > 0 || _syncFailed > 0)
                                    {
                                        <span>(@_syncSuccessful exitosas@(_syncFailed > 0 ? $", {_syncFailed} fallidas" : ""))</span>
                                    }
                                </MudText>
                            </div>
                            <MudButton Variant="Variant.Text" 
                                       Color="Color.Inherit" 
                                       OnClick="CancelSyncAll"
                                       Size="Size.Small"
                                       Class="flex-shrink-0">
                                Cancelar
                            </MudButton>
                        </div>
                    </MudAlert>
                </div>
            }

            <div class="timeline-container" id="timeline-scroll-container">
                <div class="timeline-content">
                    @if (_groupedAssets.Any())
                    {
                        @foreach (var group in _groupedAssets)
                        {
                            <div class="mb-6" id="@GetGroupId(group.Key)">
                                <MudText Typo="Typo.h6" Class="mb-3 font-weight-bold ml-1">@group.Key</MudText>
                                <MudGrid Spacing="1">
                                    @foreach (var asset in group.Value)
                                    {
                                        <MudItem xs="4" sm="3" md="2" lg="2" xl="1">
                                            <AssetCard Asset="@asset" OnAssetClick="OpenAsset" />
                                        </MudItem>
                                    }
                                </MudGrid>
                            </div>
                        }
                    }
                    else if (!_loading)
                    {
                        <MudAlert Severity="Severity.Info">No hay fotografías disponibles. Indexa un directorio para comenzar.</MudAlert>
                    }
                </div>
            </div>
        </div>
        
        <div class="timeline-sidebar">
            @if (_groupedAssets.Any())
            {
                <div class="timeline-scroll-indicator" 
                     @onmouseenter="@(() => _showTimelineIndicator = true)"
                     @onmouseleave="@(() => _showTimelineIndicator = false)"
                     @onmousemove="@OnScrollIndicatorMouseMove">
                    <div class="timeline-scroll-track">
                        <div class="timeline-scroll-progress" style="@($"height: {Math.Max(0.1, _scrollProgress)}%")"></div>
                        @foreach (var monthMarker in GetMonthMarkers())
                        {
                            <div class="timeline-month-dot" style="@($"bottom: {monthMarker.Position}%")"></div>
                        }
                        @if (_showTimelineIndicator && !string.IsNullOrEmpty(_hoverDate))
                        {
                            <div class="timeline-hover-line" style="@($"bottom: {_hoverPosition}%")">
                                <div class="timeline-hover-label">@_hoverDate</div>
                            </div>
                        }
                    </div>
                </div>
            }
        </div>
    </div>
    
    @if (_groupedAssets.Any())
    {
        <div class="timeline-nav-wrapper">
            <div id="timeline-nav-container" class="vertical-timeline-nav">
                @foreach (var group in _groupedAssets)
                {
                    var groupKey = group.Key;
                    <div class="timeline-nav-item @(IsActive(groupKey) ? "active" : "")" 
                         style="@(GetGroupStyle(groupKey))"
                         @onclick="@(() => ScrollToGroup(groupKey))">
                        <span class="timeline-nav-label">@GetYearFromGroup(groupKey)</span>
                    </div>
                }
            </div>
        </div>
    }
</div>

<style>
    /* Desactivar scroll en body/html y contenedores de MudBlazor */
    :global(body.timeline-page) {
        overflow: hidden !important;
        height: 100vh !important;
    }

    :global(body.timeline-page html) {
        overflow: hidden !important;
        height: 100vh !important;
    }

    :global(body.timeline-page .mud-layout) {
        overflow: hidden !important;
        height: 100vh !important;
    }

    :global(body.timeline-page .mud-main-content) {
        overflow: hidden !important;
        height: 100vh !important;
        position: relative !important;
    }

    /* Contenedor principal del timeline */
    .timeline-wrapper {
        position: relative;
        width: 100%;
        height: calc(100vh - 64px);
    }

    /* Contenedor principal con flex para layout horizontal */
    .timeline-main-container {
        display: flex;
        width: 100%;
        height: 100%;
        position: relative;
    }

    /* Contenedor del contenido principal */
    .timeline-content-wrapper {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    /* El contenedor del timeline es el único con scroll */
    .timeline-container {
        display: flex;
        position: relative;
        width: 100%;
        height: 100%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    /* Ocultar la barra de scroll vertical nativa */
    .timeline-container::-webkit-scrollbar {
        width: 0px;
        background: transparent;
    }

    .timeline-container {
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* IE y Edge */
    }

    .sync-alert-container {
        padding: 16px 24px;
        padding-right: 74px; /* Espacio para el sidebar + margen */
        flex-shrink: 0;
    }

    .sync-alert {
        max-width: 100%;
        margin: 0 auto;
    }

    .timeline-content {
        flex: 1;
        padding-right: 50px; /* Espacio para el sidebar */
        padding-bottom: 200px;
    }

    /* Sidebar con barra de scroll */
    .timeline-sidebar {
        width: 30px;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 40px 4px;
        flex-shrink: 0;
        background-color: transparent;
        height: 100%;
    }

    /* Contenedor del indicador de scroll */
    .timeline-scroll-indicator {
        width: 3px;
        height: 100%;
        position: relative;
        background-color: var(--mud-palette-divider);
        border-radius: 2px;
        flex-shrink: 0;
    }

    /* Track de la barra de scroll */
    .timeline-scroll-track {
        position: relative;
        width: 100%;
        height: 100%;
        border-radius: 2px;
        overflow: hidden;
    }

    /* Barra de progreso vertical */
    .timeline-scroll-progress {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 0%;
        background-color: #4285f4;
        border-radius: 2px;
        transition: height 0.1s linear;
        box-shadow: 0 0 4px rgba(66, 133, 244, 0.5);
    }

    /* Línea horizontal que aparece al hacer hover */
    .timeline-hover-line {
        position: absolute;
        left: 100%;
        width: 300px;
        height: 2px;
        background-color: #4285f4;
        margin-left: 8px;
        pointer-events: none;
        z-index: 1300;
        transform: translateY(-50%);
        box-shadow: 0 0 4px rgba(66, 133, 244, 0.6);
    }

    /* Etiqueta de fecha en la línea horizontal */
    .timeline-hover-label {
        position: absolute;
        left: 100%;
        top: 50%;
        transform: translateY(-50%);
        margin-left: 16px;
        padding: 4px 10px;
        background-color: var(--mud-palette-surface);
        color: var(--mud-palette-text-primary);
        font-size: 0.75rem;
        font-weight: 600;
        white-space: nowrap;
        border-radius: 4px;
        box-shadow: var(--mud-elevation-3);
        border: 1px solid var(--mud-palette-primary);
        pointer-events: none;
        z-index: 1301;
    }

    /* Puntos que indican los meses entre años */
    .timeline-month-dot {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        width: 3px;
        height: 3px;
        background-color: var(--mud-palette-text-secondary);
        border-radius: 50%;
        pointer-events: none;
        z-index: 1299;
        opacity: 0.5;
    }

    .timeline-nav-wrapper {
        position: fixed;
        right: 0;
        top: 64px; /* Debajo del AppBar */
        bottom: 0;
        width: 60px;
        z-index: 1200; 
        display: flex;
        justify-content: flex-end;
        background-color: transparent;
        padding-top: 20px; 
        padding-bottom: 20px; 
        pointer-events: none; 
    }

    .vertical-timeline-nav {
        position: relative;
        height: 100%;
        width: 100%;
        pointer-events: auto;
    }

    .timeline-nav-item {
        position: absolute;
        right: 0;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        transform: translateY(-50%);
        transition: all 0.2s ease;
        opacity: 0.6;
        pointer-events: auto;
        cursor: pointer;
    }

    .timeline-nav-item:hover {
        opacity: 1;
    }

    .timeline-nav-item.active {
        opacity: 1;
    }

    .timeline-nav-label {
        font-size: 0.75rem;
        font-weight: 500;
        color: var(--mud-palette-text-secondary);
        white-space: nowrap;
        transition: all 0.2s ease;
        padding-right: 8px;
    }

    .timeline-nav-item.active .timeline-nav-label {
        color: var(--mud-palette-text-primary);
        font-weight: 600;
        font-size: 0.85rem;
    }

</style>

@code {
    private List<TimelineItem> _assets = new();
    private Dictionary<string, List<TimelineItem>> _groupedAssets = new();
    private bool _loading = true;
    private string _activeGroup = "";
    private double _scrollProgress = 0;
    private bool _showTimelineIndicator = false;
    private double _hoverPosition = 0;
    private string _hoverDate = "";
    private DotNetObjectReference<Timeline>? _objRef;
    
    // Sincronización múltiple
    private int _pendingAssetsCount = 0;
    private bool _syncingAll = false;
    private string _syncProgressMessage = "";
    private double _syncProgress = 0;
    private int _syncCurrent = 0;
    private int _syncTotal = 0;
    private int _syncSuccessful = 0;
    private int _syncFailed = 0;
    private CancellationTokenSource? _syncCancellationTokenSource;

    protected override async Task OnInitializedAsync()
    {
        await LoadTimeline();
    }
    
    private string? GetDateFromQuery()
    {
        var uri = Navigation.ToAbsoluteUri(Navigation.Uri);
        if (string.IsNullOrEmpty(uri.Query))
            return null;
            
        var query = uri.Query.TrimStart('?');
        var pairs = query.Split('&');
        
        foreach (var pair in pairs)
        {
            var parts = pair.Split('=', 2);
            if (parts.Length == 2 && parts[0] == "date")
            {
                return Uri.UnescapeDataString(parts[1]);
            }
        }
        
        return null;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Agregar clase al body para aplicar estilos específicos de Timeline
            await JS.InvokeVoidAsync("scrollHelpers.enableTimelineScroll");
            
            if (_groupedAssets.Any())
            {
                await SetupScrollListener();
                
                // Inicializar el progreso del scroll después de que el listener esté configurado
                if (_objRef != null)
                {
                    await Task.Delay(100);
                    await JS.InvokeVoidAsync("scrollHelpers.updateScrollProgress", _objRef);
                }
                
                // Si hay un parámetro de fecha en la query string, hacer scroll a esa fecha
                var dateParam = GetDateFromQuery();
                if (!string.IsNullOrEmpty(dateParam))
                {
                    await ScrollToDate(dateParam);
                }
            }
        }
    }
    
    private async Task ScrollToDate(string dateString)
    {
        if (DateTime.TryParse(dateString, out var targetDate))
        {
            // Buscar el grupo que contiene esta fecha
            var targetGroup = _groupedAssets.Keys.FirstOrDefault(g => 
            {
                var groupDate = DateTime.ParseExact(g, "MMMM yyyy", new System.Globalization.CultureInfo("es-ES"));
                return groupDate.Year == targetDate.Year && groupDate.Month == targetDate.Month;
            });
            
            if (!string.IsNullOrEmpty(targetGroup))
            {
                await Task.Delay(500); // Esperar a que el DOM esté completamente renderizado
                await ScrollToGroup(targetGroup);
            }
        }
    }

    private async Task SetupScrollListener()
    {
        if (_objRef == null)
        {
            _objRef = DotNetObjectReference.Create(this);
        }
        var groupIds = _groupedAssets.Keys.Select(GetGroupId).ToList();
        // Para el hover, usar los nombres completos de los grupos (mes y año)
        var groupFullNames = _groupedAssets.Keys.ToList();
        await JS.InvokeVoidAsync("scrollHelpers.onWindowScroll", _objRef, groupIds);
        await JS.InvokeVoidAsync("scrollHelpers.setupTimelineHover", _objRef, groupIds, groupFullNames);
    }

    [JSInvokable]
    public void OnScrollUpdated(string activeGroupId, double percentage, double handleTopPixels)
    {
        _scrollProgress = percentage;
        var groupName = _groupedAssets.Keys.FirstOrDefault(k => GetGroupId(k) == activeGroupId);
        if (!string.IsNullOrEmpty(groupName))
        {
            _activeGroup = groupName;
        }
        StateHasChanged();
    }

    private double GetGroupPosition(string groupName)
    {
        if (!_groupedAssets.Any()) return 0;
        
        var keys = _groupedAssets.Keys.ToList();
        var index = keys.IndexOf(groupName);
        if (index == -1) return 0;
        
        return (double)index / (keys.Count - 1) * 100;
    }

    private string GetGroupStyle(string groupName)
    {
        return $"top: {GetGroupPosition(groupName).ToString("F2", System.Globalization.CultureInfo.InvariantCulture)}%;";
    }

    private async Task LoadTimeline()
    {
        try
        {
            _loading = true;
            _assets = await AssetService.GetTimelineAsync();
            GroupAssets();
            if (_groupedAssets.Any())
            {
                _activeGroup = _groupedAssets.Keys.First();
                // No llamamos a SetupScrollListener aquí porque necesitamos que el DOM esté listo
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error al cargar timeline: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loading = false;
        }
    }

    private void GroupAssets()
    {
        _groupedAssets = _assets
            .OrderByDescending(a => a.CreatedDate)
            .GroupBy(a => a.CreatedDate.ToString("MMMM yyyy", new System.Globalization.CultureInfo("es-ES")))
            .ToDictionary(g => char.ToUpper(g.Key[0]) + g.Key.Substring(1), g => g.ToList());
        
        // Contar assets pendientes
        _pendingAssetsCount = _assets.Count(a => a.SyncStatus == AssetSyncStatus.Pending);
    }

    private void OpenAsset(TimelineItem asset)
    {
        if (asset.SyncStatus == AssetSyncStatus.Synced)
        {
            Navigation.NavigateTo($"/asset/{asset.Id}");
        }
        else
        {
            var encodedPath = System.Net.WebUtility.UrlEncode(asset.FullPath);
            Navigation.NavigateTo($"/asset/0?path={encodedPath}");
        }
    }

    private string GetGroupId(string groupName)
    {
        return "group-" + groupName.Replace(" ", "-").ToLower();
    }

    private async Task ScrollToGroup(string groupName)
    {
        // Al hacer scroll manual, desactivamos temporalmente el listener de scroll o simplemente actualizamos el estado
        _activeGroup = groupName;
        await JS.InvokeVoidAsync("scrollHelpers.scrollToElement", GetGroupId(groupName));
    }

    private bool IsActive(string groupName) => _activeGroup == groupName;

    private void OnScrollIndicatorMouseMove(Microsoft.AspNetCore.Components.Web.MouseEventArgs e)
    {
        if (!_groupedAssets.Any() || _objRef == null) return;
        JS.InvokeVoidAsync("scrollHelpers.getTimelineHoverPosition", 
            _objRef, 
            e.ClientY);
    }

    [JSInvokable]
    public void OnHoverPositionCalculated(double percentage, string dateLabel)
    {
        _hoverPosition = percentage;
        _hoverDate = dateLabel;
        StateHasChanged();
    }

    private string GetShortLabel(string groupName)
    {
        // "Enero 2024" -> "Ene 2024"
        if (string.IsNullOrEmpty(groupName)) return "";
        var parts = groupName.Split(' ');
        if (parts.Length < 2) return groupName;
        
        var month = parts[0].Length > 3 ? parts[0].Substring(0, 3) : parts[0];
        return $"{char.ToUpper(month[0]) + month.Substring(1)} {parts[1]}";
    }

    private string GetYearFromGroup(string groupName)
    {
        // "Enero 2024" -> "2024"
        if (string.IsNullOrEmpty(groupName)) return "";
        var parts = groupName.Split(' ');
        return parts.Length >= 2 ? parts[1] : "";
    }

    private List<MonthMarker> GetMonthMarkers()
    {
        var markers = new List<MonthMarker>();
        if (!_groupedAssets.Any()) return markers;

        var groups = _groupedAssets.Keys.ToList();
        var previousYear = "";
        double previousPosition = 0;
        
        // Agrupar por año para identificar transiciones entre años
        foreach (var group in groups)
        {
            var year = GetYearFromGroup(group);
            var position = GetGroupPosition(group);
            
            // Si cambió el año, agregar un punto entre el último mes del año anterior y el primer mes del nuevo año
            if (year != previousYear && !string.IsNullOrEmpty(previousYear))
            {
                // El punto debe estar en el medio entre dos años
                var midPosition = (previousPosition + position) / 2;
                markers.Add(new MonthMarker { Position = midPosition, IsYearTransition = true });
            }
            previousYear = year;
            previousPosition = position;
        }

        return markers;
    }

    private class MonthMarker
    {
        public double Position { get; set; }
        public bool IsYearTransition { get; set; }
    }

    private async Task SyncAllPendingAssets()
    {
        var pendingAssets = _assets.Where(a => a.SyncStatus == AssetSyncStatus.Pending).ToList();
        if (!pendingAssets.Any())
        {
            Snackbar.Add("No hay fotos pendientes de sincronizar", Severity.Info);
            return;
        }

        _syncingAll = true;
        _syncTotal = pendingAssets.Count;
        _syncCurrent = 0;
        _syncSuccessful = 0;
        _syncFailed = 0;
        _syncProgress = 0;
        _syncProgressMessage = "Iniciando sincronización...";
        _syncCancellationTokenSource = new CancellationTokenSource();
        
        StateHasChanged();

        try
        {
            var paths = pendingAssets.Select(a => a.FullPath).ToList();
            
            await foreach (var update in AssetService.SyncMultipleAssetsAsync(paths, _syncCancellationTokenSource.Token))
            {
                _syncCurrent = update.Current;
                _syncTotal = update.Total;
                _syncSuccessful = update.Successful;
                _syncFailed = update.Failed;
                _syncProgress = update.Percentage;
                _syncProgressMessage = update.Message;
                
                // Actualizar el estado del asset en la lista
                var asset = _assets.FirstOrDefault(a => a.FullPath == update.CurrentPath);
                if (asset != null)
                {
                    if (update.Message.Contains("Error"))
                    {
                        asset.SyncStatus = AssetSyncStatus.Pending;
                    }
                    else
                    {
                        asset.SyncStatus = AssetSyncStatus.Copied;
                    }
                }
                
                StateHasChanged();
                
                if (update.IsCompleted)
                {
                    break;
                }
            }

            // Recargar timeline para actualizar estados
            await LoadTimeline();
            
            Snackbar.Add($"Sincronización completada: {_syncSuccessful} exitosas, {_syncFailed} fallidas", 
                _syncFailed > 0 ? Severity.Warning : Severity.Success);
        }
        catch (OperationCanceledException)
        {
            Snackbar.Add("Sincronización cancelada", Severity.Info);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error durante la sincronización: {ex.Message}", Severity.Error);
        }
        finally
        {
            _syncingAll = false;
            _syncCancellationTokenSource?.Dispose();
            _syncCancellationTokenSource = null;
            StateHasChanged();
        }
    }

    private void CancelSyncAll()
    {
        _syncCancellationTokenSource?.Cancel();
    }

    public void Dispose()
    {
        _objRef?.Dispose();
        _syncCancellationTokenSource?.Cancel();
        _syncCancellationTokenSource?.Dispose();
        // Remover clase del body al salir de la página
        JS.InvokeVoidAsync("scrollHelpers.disableTimelineScroll");
    }
}
