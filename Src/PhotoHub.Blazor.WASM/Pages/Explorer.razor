@page "/explorer"
@page "/explorer/folder/{FolderId:int}"
@using PhotoHub.Blazor.Shared.Services
@using PhotoHub.Blazor.Shared.Models
@using MudBlazor
@inject IFolderService FolderService
@inject IAssetService AssetService
@inject ISnackbar Snackbar
@inject NavigationManager Navigation

<PageTitle>Explorador - PhotoHub</PageTitle>

<style>
    .folder-card-container {
        position: relative;
        cursor: pointer;
        width: 100%;
        aspect-ratio: 1 / 1;
        overflow: hidden;
        transition: transform 0.2s, box-shadow 0.2s;
        background-color: var(--mud-palette-surface);
        border-radius: 4px;
        border: 1px solid var(--mud-palette-divider);
    }
    .folder-card-container:hover {
        transform: translateY(-4px);
        box-shadow: 0 8px 16px rgba(0,0,0,0.2);
    }
    .folder-card-thumbnail {
        width: 100%;
        height: 70%;
        object-fit: cover;
    }
    .folder-card-icon {
        width: 100%;
        height: 70%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, var(--mud-palette-primary-lighten) 0%, var(--mud-palette-primary-darken) 100%);
    }
    .folder-card-info {
        height: 30%;
        padding: 8px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        background-color: var(--mud-palette-surface);
    }
    .folder-card-name {
        font-weight: 600;
        font-size: 0.875rem;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    .folder-card-count {
        font-size: 0.75rem;
        color: var(--mud-palette-text-secondary);
    }
</style>

<MudText Typo="Typo.h4" Class="mb-4">Explorador</MudText>

<MudGrid>
    <MudItem xs="12" md="3">
        <MudCard>
            <MudCardContent>
                <MudText Typo="Typo.h6" Class="mb-3">Carpetas</MudText>
                @if (_loadingFolders)
                {
                    <MudProgressLinear Color="Color.Primary" Indeterminate="true" />
                }
                else
                {
                    <MudTreeView T="FolderItem" Items="@_treeData" SelectedValueChanged="OnFolderSelected" Hover="true" Dense="true">
                        <ItemTemplate>
                            <MudTreeViewItem @bind-Expanded="@context.Expanded" Items="@context.Children" Value="@context.Value" Icon="@context.Icon" Text="@context.Text" />
                        </ItemTemplate>
                    </MudTreeView>
                }
            </MudCardContent>
        </MudCard>
    </MudItem>
    <MudItem xs="12" md="9">
        @if (_selectedFolder != null)
        {
            <MudBreadcrumbs Items="@_breadcrumbs" MaxItems="10" />
        }
        
        @if (_loadingAssets || _loadingSubFolders)
        {
            <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="my-4" />
        }
        
        @* Mostrar subcarpetas con miniaturas *@
        @if (_subFoldersWithThumbnails.Any())
        {
            <MudText Typo="Typo.h6" Class="mt-4 mb-3">@(_selectedFolder != null ? "Carpetas" : "Carpetas raíz")</MudText>
            <MudGrid Class="mb-4">
                @foreach (var folderData in _subFoldersWithThumbnails)
                {
                    <MudItem xs="12" sm="6" md="4" lg="3" xl="2">
                        <div class="folder-card-container" @onclick="@(() => OnFolderSelected(folderData.Folder))">
                            @if (folderData.FirstAsset != null && folderData.FirstAsset.HasThumbnails)
                            {
                                <img src="@folderData.FirstAsset.ThumbnailUrl" alt="@folderData.Folder.Name" class="folder-card-thumbnail" loading="lazy" />
                            }
                            else
                            {
                                <div class="folder-card-icon">
                                    <MudIcon Icon="@Icons.Material.Filled.Folder" Size="Size.Large" Color="Color.Primary" />
                                </div>
                            }
                            
                            <div class="folder-card-info">
                                <MudText Typo="Typo.body2" Class="folder-card-name">@folderData.Folder.Name</MudText>
                                <MudText Typo="Typo.caption" Class="folder-card-count">@folderData.Folder.AssetCount archivos</MudText>
                            </div>
                        </div>
                    </MudItem>
                }
            </MudGrid>
        }
        
        @if (_selectedFolder != null)
        {
            
            @* Mostrar assets de la carpeta actual *@
            @if (_assets.Any())
            {
                <MudText Typo="Typo.h6" Class="mt-4 mb-3">Archivos</MudText>
                <MudGrid Class="mt-4">
                    @foreach (var asset in _assets)
                    {
                        <MudItem xs="12" sm="6" md="4" lg="3" xl="2">
                            <AssetCard Asset="@asset" OnAssetClick="OpenAsset" />
                        </MudItem>
                    }
                </MudGrid>
            }
            else if (!_loadingAssets && !_subFoldersWithThumbnails.Any())
            {
                <MudAlert Severity="Severity.Info" Class="mt-4">Esta carpeta no contiene archivos ni subcarpetas.</MudAlert>
            }
        }
        else if (!_loadingAssets && !_loadingSubFolders && !_subFoldersWithThumbnails.Any())
        {
            <MudAlert Severity="Severity.Info" Class="mt-4">Selecciona una carpeta para ver su contenido.</MudAlert>
        }
    </MudItem>
</MudGrid>

@code {
    [Parameter] public int? FolderId { get; set; }
    
    private List<FolderItem> _folderTree = new();
    private List<FolderItem> _allFolders = new(); // Todas las carpetas para búsqueda rápida
    private List<TreeItemData<FolderItem>> _treeData = new();
    private FolderItem? _selectedFolder;
    private List<TimelineItem> _assets = new();
    private bool _loadingFolders = true;
    private bool _loadingAssets = false;
    private bool _loadingSubFolders = false;
    private List<BreadcrumbItem> _breadcrumbs = new();
    private List<FolderWithThumbnail> _subFoldersWithThumbnails = new();
    private List<FolderItem?> _breadcrumbFolders = new(); // Lista paralela con las carpetas del breadcrumb (null = raíz)
    
    private class FolderWithThumbnail
    {
        public FolderItem Folder { get; set; } = null!;
        public TimelineItem? FirstAsset { get; set; }
    }

    private bool _isNavigating = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadFolders();
    }
    
    protected override async Task OnParametersSetAsync()
    {
        if (_isNavigating) return;
        try 
        {
            _isNavigating = true;
            await HandleFolderNavigation();
        }
        finally
        {
            _isNavigating = false;
        }
    }
    
    private async Task HandleFolderNavigation()
    {
        if (FolderId.HasValue)
        {
            // Navegar a la carpeta especificada en la URL
            var folder = await FolderService.GetFolderByIdAsync(FolderId.Value);
            if (folder != null)
            {
                // Buscar la carpeta en el árbol para obtener las subcarpetas completas
                var folderWithSubFolders = FindFolderInTreeById(FolderId.Value, _folderTree);
                if (folderWithSubFolders != null)
                {
                    folder = folderWithSubFolders;
                }
                
                _selectedFolder = folder;
                _subFoldersWithThumbnails.Clear();
                _assets.Clear();
                
                await Task.WhenAll(
                    LoadFolderAssets(folder.Id),
                    LoadSubFoldersWithThumbnails(folder),
                    UpdateBreadcrumbs(folder)
                );
            }
            else
            {
                Snackbar.Add("Carpeta no encontrada", Severity.Warning);
                Navigation.NavigateTo("/explorer");
            }
        }
        else
        {
            // Si no hay carpeta en la URL, mostrar carpetas raíz
            _selectedFolder = null;
            _assets.Clear();
            _subFoldersWithThumbnails.Clear();
            _breadcrumbs.Clear();
            _breadcrumbFolders.Clear();
            if (_folderTree.Any())
            {
                await LoadRootFoldersWithThumbnails();
            }
        }
    }
    
    private FolderItem? FindFolderInTreeById(int folderId, List<FolderItem> tree)
    {
        foreach (var folder in tree)
        {
            if (folder.Id == folderId)
            {
                return folder;
            }
            
            if (folder.SubFolders != null && folder.SubFolders.Any())
            {
                var found = FindFolderInTreeById(folderId, folder.SubFolders);
                if (found != null)
                {
                    return found;
                }
            }
        }
        
        return null;
    }
    
    private async Task LoadRootFoldersWithThumbnails()
    {
        try
        {
            _loadingSubFolders = true;
            var newList = new List<FolderWithThumbnail>();
            
            // Para cada carpeta raíz, obtener el primer asset para mostrar su miniatura
            foreach (var folder in _folderTree)
            {
                var folderData = new FolderWithThumbnail { Folder = folder };
                
                // Obtener el primer asset de la carpeta si tiene assets
                if (folder.AssetCount > 0)
                {
                    try
                    {
                        var assets = await FolderService.GetFolderAssetsAsync(folder.Id);
                        folderData.FirstAsset = assets.FirstOrDefault();
                    }
                    catch
                    {
                        // Si falla, simplemente no mostramos miniatura
                    }
                }
                
                newList.Add(folderData);
            }
            _subFoldersWithThumbnails = newList;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error al cargar carpetas raíz: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loadingSubFolders = false;
        }
    }

    private async Task LoadFolders()
    {
        try
        {
            _loadingFolders = true;
            _folderTree = await FolderService.GetFolderTreeAsync();
            _allFolders = await FolderService.GetFoldersAsync(); // Cargar todas las carpetas para búsqueda rápida
            _treeData = MapToTreeItemData(_folderTree);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error al cargar carpetas: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loadingFolders = false;
        }
    }

    private List<TreeItemData<FolderItem>> MapToTreeItemData(List<FolderItem> folders)
    {
        return folders.Select(f => new TreeItemData<FolderItem>
        {
            Value = f,
            Text = $"{f.Name} ({f.AssetCount})",
            Icon = Icons.Material.Filled.Folder,
            Children = f.SubFolders.Any() ? MapToTreeItemData(f.SubFolders) : null
        }).ToList();
    }

    private async Task OnFolderSelected(FolderItem folder)
    {
        if (folder == null) return;
        _selectedFolder = folder;
        // Limpiar para dar feedback visual de carga
        _subFoldersWithThumbnails = new List<FolderWithThumbnail>();
        _assets = new List<TimelineItem>();
        
        // Actualizar la URL sin recargar la página
        Navigation.NavigateTo($"/explorer/folder/{folder.Id}", replace: false);
    }

    private async Task OnFolderClick(FolderItem folder)
    {
        await OnFolderSelected(folder);
    }

    private async Task LoadFolderAssets(int folderId)
    {
        try
        {
            _loadingAssets = true;
            var assets = await FolderService.GetFolderAssetsAsync(folderId);
            _assets = assets ?? new List<TimelineItem>();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error al cargar archivos: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loadingAssets = false;
        }
    }

    private async Task UpdateBreadcrumbs(FolderItem folder)
    {
        _breadcrumbs = new List<BreadcrumbItem>();
        _breadcrumbFolders = new List<FolderItem?>();
        
        // Agregar "Inicio" que navega a la raíz - usar href especial para navegación
        _breadcrumbs.Add(new BreadcrumbItem("Inicio", $"/explorer"));
        _breadcrumbFolders.Add(null); // null indica que es la raíz
        
        // Construir la ruta completa desde la raíz hasta la carpeta actual
        var pathFolders = await BuildPathFolders(folder);
        
        foreach (var pathFolder in pathFolders)
        {
            var breadcrumbText = pathFolder.Name;
            // Usar href con el ID de la carpeta para navegación directa
            _breadcrumbs.Add(new BreadcrumbItem(breadcrumbText, $"/explorer/folder/{pathFolder.Id}"));
            _breadcrumbFolders.Add(pathFolder);
        }
    }
    
    private async Task<List<FolderItem>> BuildPathFolders(FolderItem folder)
    {
        var pathFolders = new List<FolderItem>();
        
        // Primero intentar buscar la carpeta en el árbol para obtener la ruta completa
        var folderPath = FindFolderInTree(folder.Id, _folderTree);
        if (folderPath != null && folderPath.Any())
        {
            pathFolders = folderPath;
        }
        else
        {
            // Si no se encuentra en el árbol, construir la ruta usando el path
            if (!string.IsNullOrEmpty(folder.Path))
            {
                var pathParts = folder.Path.Split(new[] { '/', '\\' }, StringSplitOptions.RemoveEmptyEntries);
                var currentPath = "";
                
                foreach (var part in pathParts)
                {
                    currentPath = string.IsNullOrEmpty(currentPath) ? part : $"{currentPath}/{part}";
                    var normalizedCurrentPath = currentPath.Replace('\\', '/').TrimEnd('/');
                    
                    // Buscar la carpeta por su path completo en el árbol
                    var foundFolder = FindFolderByPathInTree(normalizedCurrentPath, _folderTree);
                    if (foundFolder != null)
                    {
                        pathFolders.Add(foundFolder);
                    }
                    else
                    {
                        // Si no se encuentra en el árbol, buscar en todas las carpetas cargadas
                        var folderByPath = _allFolders.FirstOrDefault(f => 
                        {
                            var folderNormalizedPath = f.Path.Replace('\\', '/').TrimEnd('/');
                            return folderNormalizedPath.Equals(normalizedCurrentPath, StringComparison.OrdinalIgnoreCase);
                        });
                        
                        if (folderByPath != null)
                        {
                            pathFolders.Add(folderByPath);
                        }
                    }
                }
            }
            
            // Si aún no tenemos la ruta completa, construir usando ParentFolderId
            if (!pathFolders.Any() || pathFolders.LastOrDefault()?.Id != folder.Id)
            {
                // Construir la ruta desde la carpeta actual hacia arriba usando ParentFolderId
                var pathFromParent = await BuildPathFromParent(folder);
                if (pathFromParent.Any())
                {
                    pathFolders = pathFromParent;
                }
                else
                {
                    // Si todo falla, agregar solo la carpeta actual
                    pathFolders.Add(folder);
                }
            }
        }
        
        return pathFolders;
    }
    
    private async Task<List<FolderItem>> BuildPathFromParent(FolderItem folder)
    {
        var path = new List<FolderItem>();
        var currentFolder = folder;
        var visited = new HashSet<int>(); // Para evitar ciclos
        
        // Construir la ruta desde la carpeta actual hacia arriba
        while (currentFolder != null && !visited.Contains(currentFolder.Id))
        {
            visited.Add(currentFolder.Id);
            path.Insert(0, currentFolder); // Insertar al inicio para mantener el orden
            
            if (currentFolder.ParentFolderId.HasValue)
            {
                var parentId = currentFolder.ParentFolderId.Value;
                // Buscar la carpeta padre en las carpetas cargadas
                var parentFolder = _allFolders.FirstOrDefault(f => f.Id == parentId);
                if (parentFolder == null)
                {
                    // Si no está en las carpetas cargadas, intentar obtenerla del API
                    try
                    {
                        parentFolder = await FolderService.GetFolderByIdAsync(parentId);
                    }
                    catch
                    {
                        break;
                    }
                }
                currentFolder = parentFolder;
            }
            else
            {
                break;
            }
        }
        
        return path;
    }
    
    private FolderItem? FindFolderByPathInTree(string path, List<FolderItem> tree)
    {
        var normalizedPath = path.Replace('\\', '/').TrimEnd('/');
        
        foreach (var folder in tree)
        {
            var folderPath = folder.Path.Replace('\\', '/').TrimEnd('/');
            if (folderPath.Equals(normalizedPath, StringComparison.OrdinalIgnoreCase))
            {
                return folder;
            }
            
            if (folder.SubFolders != null && folder.SubFolders.Any())
            {
                var found = FindFolderByPathInTree(path, folder.SubFolders);
                if (found != null)
                {
                    return found;
                }
            }
        }
        
        return null;
    }
    
    private List<FolderItem>? FindFolderInTree(int folderId, List<FolderItem> tree, List<FolderItem>? currentPath = null)
    {
        if (currentPath == null)
        {
            currentPath = new List<FolderItem>();
        }
        
        foreach (var folder in tree)
        {
            var newPath = new List<FolderItem>(currentPath) { folder };
            
            if (folder.Id == folderId)
            {
                return newPath;
            }
            
            if (folder.SubFolders != null && folder.SubFolders.Any())
            {
                var found = FindFolderInTree(folderId, folder.SubFolders, newPath);
                if (found != null)
                {
                    return found;
                }
            }
        }
        
        return null;
    }
    
    private FolderItem? FindFolderByNameInTree(string name, List<FolderItem> tree)
    {
        foreach (var folder in tree)
        {
            if (folder.Name.Equals(name, StringComparison.OrdinalIgnoreCase))
            {
                return folder;
            }
            
            if (folder.SubFolders != null && folder.SubFolders.Any())
            {
                var found = FindFolderByNameInTree(name, folder.SubFolders);
                if (found != null)
                {
                    return found;
                }
            }
        }
        
        return null;
    }

    private async Task LoadSubFoldersWithThumbnails(FolderItem folder)
    {
        try
        {
            _loadingSubFolders = true;
            var newList = new List<FolderWithThumbnail>();
            
            // Si la carpeta no tiene subcarpetas en el objeto, intentar obtenerlas del árbol
            if (folder.SubFolders == null || !folder.SubFolders.Any())
            {
                // Buscar la carpeta en el árbol para obtener las subcarpetas
                var folderInTree = FindFolderInTreeById(folder.Id, _folderTree);
                if (folderInTree != null && folderInTree.SubFolders != null && folderInTree.SubFolders.Any())
                {
                    folder.SubFolders = folderInTree.SubFolders;
                }
                else
                {
                    // Si no hay subcarpetas, limpiar y retornar
                    _subFoldersWithThumbnails = newList;
                    return;
                }
            }
            
            // Para cada subcarpeta, obtener el primer asset para mostrar su miniatura
            foreach (var subFolder in folder.SubFolders)
            {
                var folderData = new FolderWithThumbnail { Folder = subFolder };
                
                // Obtener el primer asset de la subcarpeta si tiene assets
                if (subFolder.AssetCount > 0)
                {
                    try
                    {
                        var assets = await FolderService.GetFolderAssetsAsync(subFolder.Id);
                        folderData.FirstAsset = assets.FirstOrDefault();
                    }
                    catch
                    {
                        // Si falla, simplemente no mostramos miniatura
                    }
                }
                
                newList.Add(folderData);
            }
            
            _subFoldersWithThumbnails = newList;
            // Forzar actualización de la UI
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error al cargar subcarpetas: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loadingSubFolders = false;
        }
    }

    private void OpenAsset(TimelineItem asset)
    {
        Navigation.NavigateTo($"/asset/{asset.Id}");
    }
}
