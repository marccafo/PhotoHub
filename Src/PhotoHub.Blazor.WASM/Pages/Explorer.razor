@page "/explorer"
@page "/explorer/folder/{FolderId:int}"
@using PhotoHub.Blazor.Shared.Models
@inject IFolderService FolderService
@inject IAssetService AssetService
@inject ISnackbar Snackbar
@inject NavigationManager Navigation
@inject IAuthService AuthService

<PageTitle>Explorador - PhotoHub</PageTitle>

<style>
    .folder-card-container {
        position: relative;
        cursor: pointer;
        width: 100%;
        aspect-ratio: 1 / 1;
        overflow: hidden;
        transition: transform 0.2s, box-shadow 0.2s;
        background-color: var(--mud-palette-surface);
        border-radius: 4px;
        border: 1px solid var(--mud-palette-divider);
    }
    .folder-card-container:hover {
        transform: translateY(-4px);
        box-shadow: 0 8px 16px rgba(0,0,0,0.2);
    }
    .folder-card-thumbnail {
        width: 100%;
        height: 70%;
        object-fit: cover;
    }
    .folder-card-icon {
        width: 100%;
        height: 70%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, var(--mud-palette-primary-lighten) 0%, var(--mud-palette-primary-darken) 100%);
    }
    .folder-card-info {
        height: 30%;
        padding: 8px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        background-color: var(--mud-palette-surface);
    }
    .folder-card-name {
        font-weight: 600;
        font-size: 0.875rem;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    .folder-card-count {
        font-size: 0.75rem;
        color: var(--mud-palette-text-secondary);
    }
</style>

<MudText Typo="Typo.h4" Class="mb-4">Explorador</MudText>

<MudGrid>
    <MudItem xs="12" md="3">
        <MudCard>
            <MudCardContent>
                <MudText Typo="Typo.h6" Class="mb-3">Carpetas</MudText>
                @if (_loadingFolders)
                {
                    <MudProgressLinear Color="Color.Primary" Indeterminate="true" />
                }
                else
                {
                    <MudTreeView T="FolderItem"
                                 Items="@_treeData"
                                 SelectedValue="@_selectedTreeFolder"
                                 SelectedValueChanged="OnFolderSelected"
                                 Hover="true"
                                 Dense="true">
                        <ItemTemplate>
                            <MudTreeViewItem @bind-Expanded="@context.Expanded" Items="@context.Children" Value="@context.Value" Icon="@context.Icon" Text="@context.Text" />
                        </ItemTemplate>
                    </MudTreeView>
                }
            </MudCardContent>
        </MudCard>
    </MudItem>
    <MudItem xs="12" md="9">
        <div class="d-flex justify-space-between align-center mb-2">
            <div class="d-flex align-center">
                <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.CreateNewFolder" OnClick="OpenCreateFolderDialog">
                    Nueva carpeta
                </MudButton>
                <MudButton Variant="Variant.Text" Disabled="@(_selectedFolder == null)" Class="ml-2" OnClick="OpenEditFolderDialog">
                    Renombrar
                </MudButton>
                <MudButton Variant="Variant.Text" Disabled="@(_selectedFolder == null)" Class="ml-2" OnClick="OpenDeleteFolderDialog">
                    Eliminar
                </MudButton>
                <MudButton Variant="Variant.Text" Disabled="@(_selectedFolder == null || !_assets.Any())" Class="ml-2" OnClick="OpenMoveAssetsDialog">
                    Mover archivos
                </MudButton>
            </div>
        </div>

        @if (_selectedFolder != null)
        {
            <MudBreadcrumbs Items="@_breadcrumbs" MaxItems="10" />
        }
        
        @if (_loadingAssets || _loadingSubFolders)
        {
            <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="my-4" />
        }
        
        @* Mostrar subcarpetas con miniaturas *@
        @if (_subFoldersWithThumbnails.Any())
        {
            <MudText Typo="Typo.h6" Class="mt-4 mb-3">@(_selectedFolder != null ? "Carpetas" : "Carpetas raíz")</MudText>
            <MudGrid Class="mb-4">
                @foreach (var folderData in _subFoldersWithThumbnails)
                {
                    <MudItem xs="12" sm="6" md="4" lg="3" xl="2">
                        <div class="folder-card-container" @onclick="@(() => OnFolderSelected(folderData.Folder))">
                            @if (folderData.FirstAsset != null && folderData.FirstAsset.HasThumbnails)
                            {
                                <img src="@folderData.FirstAsset.ThumbnailUrl" alt="@folderData.Folder.Name" class="folder-card-thumbnail" loading="lazy" />
                            }
                            else
                            {
                                <div class="folder-card-icon">
                                    <MudIcon Icon="@Icons.Material.Filled.Folder" Size="Size.Large" Color="Color.Primary" />
                                </div>
                            }
                            
                            <div class="folder-card-info">
                                <MudText Typo="Typo.body2" Class="folder-card-name">@GetDisplayFolderName(folderData.Folder)</MudText>
                                <MudText Typo="Typo.caption" Class="folder-card-count">@folderData.Folder.AssetCount archivos</MudText>
                            </div>
                        </div>
                    </MudItem>
                }
            </MudGrid>
        }
        
        @if (_selectedFolder != null)
        {
            
            @* Mostrar assets de la carpeta actual *@
            @if (_assets.Any())
            {
                <MudText Typo="Typo.h6" Class="mt-4 mb-3">Archivos</MudText>
                <MudGrid Class="mt-4">
                    @foreach (var asset in _assets)
                    {
                        <MudItem xs="12" sm="6" md="4" lg="3" xl="2">
                            <AssetCard Asset="@asset" OnAssetClick="OpenAsset" />
                        </MudItem>
                    }
                </MudGrid>
            }
            else if (!_loadingAssets && !_subFoldersWithThumbnails.Any())
            {
                <MudAlert Severity="Severity.Info" Class="mt-4">Esta carpeta no contiene archivos ni subcarpetas.</MudAlert>
            }
        }
        else if (!_loadingAssets && !_loadingSubFolders && !_subFoldersWithThumbnails.Any())
        {
            <MudAlert Severity="Severity.Info" Class="mt-4">Selecciona una carpeta para ver su contenido.</MudAlert>
        }
    </MudItem>
</MudGrid>

<MudDialog @bind-Visible="_createFolderDialogVisible" Options="@(new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true })">
    <TitleContent>
        <MudText Typo="Typo.h6">Nueva carpeta</MudText>
    </TitleContent>
    <DialogContent>
        <MudTextField @bind-Value="_folderNameInput" Label="Nombre" Variant="Variant.Outlined" FullWidth="true" />
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="CloseCreateFolderDialog">Cancelar</MudButton>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="CreateFolderAsync">Crear</MudButton>
    </DialogActions>
</MudDialog>

<MudDialog @bind-Visible="_editFolderDialogVisible" Options="@(new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true })">
    <TitleContent>
        <MudText Typo="Typo.h6">Editar carpeta</MudText>
    </TitleContent>
    <DialogContent>
        <MudTextField @bind-Value="_folderNameInput" Label="Nombre" Variant="Variant.Outlined" FullWidth="true" Class="mb-3" />
        <MudAutocomplete T="int?"
                         Label="Carpeta padre"
                         Variant="Variant.Outlined"
                         @bind-Value="_editParentFolderId"
                         SearchFunc="SearchEditParentFolderAsync"
                         ToStringFunc="EditParentFolderToString"
                         ResetValueOnEmptyText="true"
                         CoerceText="true"
                         FullWidth="true" />
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="CloseEditFolderDialog">Cancelar</MudButton>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="UpdateFolderAsync">Guardar</MudButton>
    </DialogActions>
</MudDialog>

<MudDialog @bind-Visible="_deleteFolderDialogVisible" Options="@(new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true })">
    <TitleContent>
        <MudText Typo="Typo.h6">Eliminar carpeta</MudText>
    </TitleContent>
    <DialogContent>
        <MudText>¿Estás seguro de que quieres eliminar la carpeta "@_selectedFolder?.Name"?</MudText>
        <MudText Typo="Typo.caption" Class="mud-text-secondary">Debe estar vacía para poder eliminarla.</MudText>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="CloseDeleteFolderDialog">Cancelar</MudButton>
        <MudButton Color="Color.Error" Variant="Variant.Filled" OnClick="DeleteFolderAsync">Eliminar</MudButton>
    </DialogActions>
</MudDialog>

<MudDialog @bind-Visible="_moveAssetsDialogVisible" Options="@(new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Medium, FullWidth = true })">
    <TitleContent>
        <MudText Typo="Typo.h6">Mover archivos</MudText>
    </TitleContent>
    <DialogContent>
        <MudAutocomplete T="int?"
                         Label="Destino"
                         Variant="Variant.Outlined"
                         @bind-Value="_moveTargetFolderId"
                         SearchFunc="SearchMoveFolderAsync"
                         ToStringFunc="MoveFolderToString"
                         ResetValueOnEmptyText="true"
                         CoerceText="true"
                         FullWidth="true"
                         Class="mb-3" />

        <MudButton Variant="Variant.Text" OnClick="ToggleSelectAllAssets" Disabled="@(!_assets.Any())" Class="mb-2">
            @(_selectedAssetIds.Count == _assets.Count ? "Deseleccionar todo" : "Seleccionar todo")
        </MudButton>

        <MudTable Items="@_assets" Dense="true" Hover="true">
            <HeaderContent>
                <MudTh></MudTh>
                <MudTh>Archivo</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="">
                    <MudCheckBox T="bool"
                                 Value="@_selectedAssetIds.Contains(context.Id)"
                                 ValueChanged="@(EventCallback.Factory.Create<bool>(this, value => ToggleAssetSelection(context.Id, value)))" />
                </MudTd>
                <MudTd DataLabel="Archivo">@context.FileName</MudTd>
            </RowTemplate>
        </MudTable>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="CloseMoveAssetsDialog">Cancelar</MudButton>
        <MudButton Color="Color.Primary" Variant="Variant.Filled" Disabled="@(!_selectedAssetIds.Any() || !_moveTargetFolderId.HasValue)" OnClick="MoveAssetsAsync">Mover</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [Parameter] public int? FolderId { get; set; }
    
    private List<FolderItem> _folderTree = new();
    private List<FolderItem> _allFolders = new(); // Todas las carpetas para búsqueda rápida
    private List<TreeItemData<FolderItem>> _treeData = new();
    private FolderItem? _selectedFolder;
    private FolderItem? _selectedTreeFolder;
    private List<TimelineItem> _assets = new();
    private bool _loadingFolders = true;
    private bool _loadingAssets = false;
    private bool _loadingSubFolders = false;
    private List<BreadcrumbItem> _breadcrumbs = new();
    private List<FolderWithThumbnail> _subFoldersWithThumbnails = new();
    private List<FolderItem?> _breadcrumbFolders = new(); // Lista paralela con las carpetas del breadcrumb (null = raíz)

    private bool _createFolderDialogVisible = false;
    private bool _editFolderDialogVisible = false;
    private bool _deleteFolderDialogVisible = false;
    private bool _moveAssetsDialogVisible = false;
    private string _folderNameInput = string.Empty;
    private int? _editParentFolderId;
    private int? _moveTargetFolderId;
    private HashSet<int> _selectedAssetIds = new();
    private int? _userId;
    private string _userRootPrefix = string.Empty;
    private string _userRootPhysicalPrefix = string.Empty;
    
    private class FolderWithThumbnail
    {
        public FolderItem Folder { get; set; } = null!;
        public TimelineItem? FirstAsset { get; set; }
    }

    private bool _isNavigating = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadUserRootAsync();
        await LoadFolders();
    }
    
    protected override async Task OnParametersSetAsync()
    {
        if (_isNavigating) return;
        try 
        {
            _isNavigating = true;
            await HandleFolderNavigation();
        }
        finally
        {
            _isNavigating = false;
        }
    }
    
    private async Task HandleFolderNavigation()
    {
        if (FolderId.HasValue)
        {
            // Navegar a la carpeta especificada en la URL
            var folder = await FolderService.GetFolderByIdAsync(FolderId.Value);
            if (folder != null)
            {
                // Buscar la carpeta en el árbol para obtener las subcarpetas completas
                var folderWithSubFolders = FindFolderInTreeById(FolderId.Value, _folderTree);
                if (folderWithSubFolders != null)
                {
                    folder = folderWithSubFolders;
                }
                
                _selectedFolder = folder;
                _selectedTreeFolder = folder;
                _subFoldersWithThumbnails.Clear();
                _assets.Clear();
                
                await Task.WhenAll(
                    LoadFolderAssets(folder.Id),
                    LoadSubFoldersWithThumbnails(folder),
                    UpdateBreadcrumbs(folder)
                );
            }
            else
            {
                Snackbar.Add("Carpeta no encontrada", Severity.Warning);
                Navigation.NavigateTo("/explorer");
            }
        }
        else
        {
            // Si no hay carpeta en la URL, ir directamente a Inicio
            var rootFolder = FindUserRootFolder();
            if (rootFolder != null)
            {
                Navigation.NavigateTo($"/explorer/folder/{rootFolder.Id}", replace: true);
                return;
            }

            _selectedFolder = null;
            _selectedTreeFolder = null;
            _assets.Clear();
            _subFoldersWithThumbnails.Clear();
            _breadcrumbs.Clear();
            _breadcrumbFolders.Clear();
        }
    }

    private FolderItem? FindUserRootFolder()
    {
        if (!_allFolders.Any())
        {
            return null;
        }

        if (!string.IsNullOrEmpty(_userRootPrefix))
        {
            var normalizedRoot = _userRootPrefix.TrimEnd('/');
            var match = _allFolders.FirstOrDefault(f =>
                f.Path.Replace('\\', '/').TrimEnd('/').Equals(normalizedRoot, StringComparison.OrdinalIgnoreCase));
            if (match != null)
            {
                return match;
            }
        }

        if (!string.IsNullOrEmpty(_userRootPhysicalPrefix))
        {
            var normalizedRoot = _userRootPhysicalPrefix.TrimEnd('/');
            return _allFolders.FirstOrDefault(f =>
                f.Path.Replace('\\', '/').TrimEnd('/').Equals(normalizedRoot, StringComparison.OrdinalIgnoreCase));
        }

        return null;
    }
    
    private FolderItem? FindFolderInTreeById(int folderId, List<FolderItem> tree)
    {
        foreach (var folder in tree)
        {
            if (folder.Id == folderId)
            {
                return folder;
            }
            
            if (folder.SubFolders != null && folder.SubFolders.Any())
            {
                var found = FindFolderInTreeById(folderId, folder.SubFolders);
                if (found != null)
                {
                    return found;
                }
            }
        }
        
        return null;
    }
    
    private async Task LoadRootFoldersWithThumbnails()
    {
        try
        {
            _loadingSubFolders = true;
            var newList = new List<FolderWithThumbnail>();
            
            // Para cada carpeta raíz, obtener el primer asset para mostrar su miniatura
            foreach (var folder in _folderTree)
            {
                var folderData = new FolderWithThumbnail { Folder = folder };
                
                // Obtener el primer asset de la carpeta si tiene assets
                if (folder.AssetCount > 0)
                {
                    try
                    {
                        var assets = await FolderService.GetFolderAssetsAsync(folder.Id);
                        folderData.FirstAsset = assets.FirstOrDefault();
                    }
                    catch
                    {
                        // Si falla, simplemente no mostramos miniatura
                    }
                }
                
                newList.Add(folderData);
            }
            _subFoldersWithThumbnails = newList;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error al cargar carpetas raíz: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loadingSubFolders = false;
        }
    }

    private async Task LoadFolders()
    {
        try
        {
            _loadingFolders = true;
            _folderTree = await FolderService.GetFolderTreeAsync();
            _allFolders = await FolderService.GetFoldersAsync(); // Cargar todas las carpetas para búsqueda rápida
            UpdateUserRootPhysicalPrefix();
            FilterFoldersToUserRoot();
            _treeData = MapToTreeItemData(_folderTree);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error al cargar carpetas: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loadingFolders = false;
        }
    }

    private List<TreeItemData<FolderItem>> MapToTreeItemData(List<FolderItem> folders)
    {
        return folders.Select(f => new TreeItemData<FolderItem>
        {
            Value = f,
            Text = $"{GetDisplayFolderName(f)} ({f.AssetCount})",
            Icon = Icons.Material.Filled.Folder,
            Children = f.SubFolders.Any() ? MapToTreeItemData(f.SubFolders) : null
        }).ToList();
    }

    private Task OnFolderSelected(FolderItem folder)
    {
        if (folder == null) return Task.CompletedTask;
        _selectedFolder = folder;
        // Limpiar para dar feedback visual de carga
        _subFoldersWithThumbnails = new List<FolderWithThumbnail>();
        _assets = new List<TimelineItem>();
        
        // Actualizar la URL sin recargar la página
        Navigation.NavigateTo($"/explorer/folder/{folder.Id}", replace: false);
        return Task.CompletedTask;
    }

    private async Task OnFolderClick(FolderItem folder)
    {
        await OnFolderSelected(folder);
    }

    private async Task LoadFolderAssets(int folderId)
    {
        try
        {
            _loadingAssets = true;
            var assets = await FolderService.GetFolderAssetsAsync(folderId);
            _assets = assets ?? new List<TimelineItem>();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error al cargar archivos: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loadingAssets = false;
        }
    }

    private async Task UpdateBreadcrumbs(FolderItem folder)
    {
        _breadcrumbs = new List<BreadcrumbItem>();
        _breadcrumbFolders = new List<FolderItem?>();
        
        // Agregar "Inicio" que navega a la raíz - usar href especial para navegación
        _breadcrumbs.Add(new BreadcrumbItem("Inicio", $"/explorer"));
        _breadcrumbFolders.Add(null); // null indica que es la raíz
        
        // Construir la ruta completa desde la raíz hasta la carpeta actual
        var pathFolders = await BuildPathFolders(folder);
        
        var skipRoot = pathFolders.FirstOrDefault() != null &&
                       IsUserRootPath(pathFolders.First()!.Path.Replace('\\', '/'));

        foreach (var pathFolder in pathFolders)
        {
            if (skipRoot)
            {
                skipRoot = false;
                continue;
            }
            var breadcrumbText = GetDisplayFolderName(pathFolder);
            // Usar href con el ID de la carpeta para navegación directa
            _breadcrumbs.Add(new BreadcrumbItem(breadcrumbText, $"/explorer/folder/{pathFolder.Id}"));
            _breadcrumbFolders.Add(pathFolder);
        }
    }
    
    private async Task<List<FolderItem>> BuildPathFolders(FolderItem folder)
    {
        var pathFolders = new List<FolderItem>();
        
        // Primero intentar buscar la carpeta en el árbol para obtener la ruta completa
        var folderPath = FindFolderInTree(folder.Id, _folderTree);
        if (folderPath != null && folderPath.Any())
        {
            pathFolders = folderPath;
        }
        else
        {
            // Si no se encuentra en el árbol, construir la ruta usando el path
            if (!string.IsNullOrEmpty(folder.Path))
            {
                var pathParts = folder.Path.Split(new[] { '/', '\\' }, StringSplitOptions.RemoveEmptyEntries);
                var currentPath = "";
                
                foreach (var part in pathParts)
                {
                    currentPath = string.IsNullOrEmpty(currentPath) ? part : $"{currentPath}/{part}";
                    var normalizedCurrentPath = currentPath.Replace('\\', '/').TrimEnd('/');
                    
                    // Buscar la carpeta por su path completo en el árbol
                    var foundFolder = FindFolderByPathInTree(normalizedCurrentPath, _folderTree);
                    if (foundFolder != null)
                    {
                        pathFolders.Add(foundFolder);
                    }
                    else
                    {
                        // Si no se encuentra en el árbol, buscar en todas las carpetas cargadas
                        var folderByPath = _allFolders.FirstOrDefault(f => 
                        {
                            var folderNormalizedPath = f.Path.Replace('\\', '/').TrimEnd('/');
                            return folderNormalizedPath.Equals(normalizedCurrentPath, StringComparison.OrdinalIgnoreCase);
                        });
                        
                        if (folderByPath != null)
                        {
                            pathFolders.Add(folderByPath);
                        }
                    }
                }
            }
            
            // Si aún no tenemos la ruta completa, construir usando ParentFolderId
            if (!pathFolders.Any() || pathFolders.LastOrDefault()?.Id != folder.Id)
            {
                // Construir la ruta desde la carpeta actual hacia arriba usando ParentFolderId
                var pathFromParent = await BuildPathFromParent(folder);
                if (pathFromParent.Any())
                {
                    pathFolders = pathFromParent;
                }
                else
                {
                    // Si todo falla, agregar solo la carpeta actual
                    pathFolders.Add(folder);
                }
            }
        }
        
        return pathFolders;
    }
    
    private async Task<List<FolderItem>> BuildPathFromParent(FolderItem folder)
    {
        var path = new List<FolderItem>();
        var currentFolder = folder;
        var visited = new HashSet<int>(); // Para evitar ciclos
        
        // Construir la ruta desde la carpeta actual hacia arriba
        while (currentFolder != null && !visited.Contains(currentFolder.Id))
        {
            visited.Add(currentFolder.Id);
            path.Insert(0, currentFolder); // Insertar al inicio para mantener el orden
            
            if (currentFolder.ParentFolderId.HasValue)
            {
                var parentId = currentFolder.ParentFolderId.Value;
                // Buscar la carpeta padre en las carpetas cargadas
                var parentFolder = _allFolders.FirstOrDefault(f => f.Id == parentId);
                if (parentFolder == null)
                {
                    // Si no está en las carpetas cargadas, intentar obtenerla del API
                    try
                    {
                        parentFolder = await FolderService.GetFolderByIdAsync(parentId);
                    }
                    catch
                    {
                        break;
                    }
                }
                currentFolder = parentFolder;
            }
            else
            {
                break;
            }
        }
        
        return path;
    }
    
    private FolderItem? FindFolderByPathInTree(string path, List<FolderItem> tree)
    {
        var normalizedPath = path.Replace('\\', '/').TrimEnd('/');
        
        foreach (var folder in tree)
        {
            var folderPath = folder.Path.Replace('\\', '/').TrimEnd('/');
            if (folderPath.Equals(normalizedPath, StringComparison.OrdinalIgnoreCase))
            {
                return folder;
            }
            
            if (folder.SubFolders != null && folder.SubFolders.Any())
            {
                var found = FindFolderByPathInTree(path, folder.SubFolders);
                if (found != null)
                {
                    return found;
                }
            }
        }
        
        return null;
    }
    
    private List<FolderItem>? FindFolderInTree(int folderId, List<FolderItem> tree, List<FolderItem>? currentPath = null)
    {
        if (currentPath == null)
        {
            currentPath = new List<FolderItem>();
        }
        
        foreach (var folder in tree)
        {
            var newPath = new List<FolderItem>(currentPath) { folder };
            
            if (folder.Id == folderId)
            {
                return newPath;
            }
            
            if (folder.SubFolders != null && folder.SubFolders.Any())
            {
                var found = FindFolderInTree(folderId, folder.SubFolders, newPath);
                if (found != null)
                {
                    return found;
                }
            }
        }
        
        return null;
    }
    
    private FolderItem? FindFolderByNameInTree(string name, List<FolderItem> tree)
    {
        foreach (var folder in tree)
        {
            if (folder.Name.Equals(name, StringComparison.OrdinalIgnoreCase))
            {
                return folder;
            }
            
            if (folder.SubFolders != null && folder.SubFolders.Any())
            {
                var found = FindFolderByNameInTree(name, folder.SubFolders);
                if (found != null)
                {
                    return found;
                }
            }
        }
        
        return null;
    }

    private async Task LoadSubFoldersWithThumbnails(FolderItem folder)
    {
        try
        {
            _loadingSubFolders = true;
            var newList = new List<FolderWithThumbnail>();
            
            // Si la carpeta no tiene subcarpetas en el objeto, intentar obtenerlas del árbol
            if (folder.SubFolders == null || !folder.SubFolders.Any())
            {
                // Buscar la carpeta en el árbol para obtener las subcarpetas
                var folderInTree = FindFolderInTreeById(folder.Id, _folderTree);
                if (folderInTree != null && folderInTree.SubFolders != null && folderInTree.SubFolders.Any())
                {
                    folder.SubFolders = folderInTree.SubFolders;
                }
                else
                {
                    // Si no hay subcarpetas, limpiar y retornar
                    _subFoldersWithThumbnails = newList;
                    return;
                }
            }
            
            // Para cada subcarpeta, obtener el primer asset para mostrar su miniatura
            foreach (var subFolder in folder.SubFolders)
            {
                var folderData = new FolderWithThumbnail { Folder = subFolder };
                
                // Obtener el primer asset de la subcarpeta si tiene assets
                if (subFolder.AssetCount > 0)
                {
                    try
                    {
                        var assets = await FolderService.GetFolderAssetsAsync(subFolder.Id);
                        folderData.FirstAsset = assets.FirstOrDefault();
                    }
                    catch
                    {
                        // Si falla, simplemente no mostramos miniatura
                    }
                }
                
                newList.Add(folderData);
            }
            
            _subFoldersWithThumbnails = newList;
            // Forzar actualización de la UI
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error al cargar subcarpetas: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loadingSubFolders = false;
        }
    }

    private void OpenAsset(TimelineItem asset)
    {
        Navigation.NavigateTo($"/asset/{asset.Id}");
    }

    private void OpenCreateFolderDialog()
    {
        _folderNameInput = string.Empty;
        _createFolderDialogVisible = true;
    }

    private void CloseCreateFolderDialog()
    {
        _createFolderDialogVisible = false;
    }

    private async Task CreateFolderAsync()
    {
        if (string.IsNullOrWhiteSpace(_folderNameInput))
        {
            Snackbar.Add("El nombre de la carpeta es obligatorio", Severity.Warning);
            return;
        }

        try
        {
            var request = new CreateFolderRequest
            {
                Name = _folderNameInput.Trim(),
                ParentFolderId = _selectedFolder?.Id
            };

            var created = await FolderService.CreateFolderAsync(request);
            _createFolderDialogVisible = false;
            await LoadFolders();
            Navigation.NavigateTo($"/explorer/folder/{created.Id}");
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error al crear carpeta: {ex.Message}", Severity.Error);
        }
    }

    private void OpenEditFolderDialog()
    {
        if (_selectedFolder == null) return;
        _folderNameInput = _selectedFolder.Name;
        _editParentFolderId = _selectedFolder.ParentFolderId;
        _editFolderDialogVisible = true;
    }

    private void CloseEditFolderDialog()
    {
        _editFolderDialogVisible = false;
    }

    private async Task UpdateFolderAsync()
    {
        if (_selectedFolder == null)
        {
            return;
        }

        if (string.IsNullOrWhiteSpace(_folderNameInput))
        {
            Snackbar.Add("El nombre de la carpeta es obligatorio", Severity.Warning);
            return;
        }

        try
        {
            var request = new UpdateFolderRequest
            {
                Name = _folderNameInput.Trim(),
                ParentFolderId = _editParentFolderId
            };

            await FolderService.UpdateFolderAsync(_selectedFolder.Id, request);
            _editFolderDialogVisible = false;
            await LoadFolders();
            Navigation.NavigateTo($"/explorer/folder/{_selectedFolder.Id}");
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error al actualizar carpeta: {ex.Message}", Severity.Error);
        }
    }

    private void OpenDeleteFolderDialog()
    {
        if (_selectedFolder == null) return;
        _deleteFolderDialogVisible = true;
    }

    private void CloseDeleteFolderDialog()
    {
        _deleteFolderDialogVisible = false;
    }

    private async Task DeleteFolderAsync()
    {
        if (_selectedFolder == null) return;

        try
        {
            await FolderService.DeleteFolderAsync(_selectedFolder.Id);
            _deleteFolderDialogVisible = false;
            Navigation.NavigateTo("/explorer");
            await LoadFolders();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error al eliminar carpeta: {ex.Message}", Severity.Error);
        }
    }

    private void OpenMoveAssetsDialog()
    {
        if (_selectedFolder == null) return;
        _moveTargetFolderId = null;
        _selectedAssetIds = new HashSet<int>();
        _moveAssetsDialogVisible = true;
    }

    private void CloseMoveAssetsDialog()
    {
        _moveAssetsDialogVisible = false;
    }

    private void ToggleAssetSelection(int assetId, bool selected)
    {
        if (selected)
        {
            _selectedAssetIds.Add(assetId);
        }
        else
        {
            _selectedAssetIds.Remove(assetId);
        }
        StateHasChanged();
    }

    private void ToggleSelectAllAssets()
    {
        if (_selectedAssetIds.Count == _assets.Count)
        {
            _selectedAssetIds.Clear();
        }
        else
        {
            _selectedAssetIds = _assets.Select(a => a.Id).ToHashSet();
        }
        StateHasChanged();
    }

    private async Task MoveAssetsAsync()
    {
        if (_selectedFolder == null || !_moveTargetFolderId.HasValue || !_selectedAssetIds.Any())
        {
            return;
        }

        try
        {
            var request = new MoveFolderAssetsRequest
            {
                SourceFolderId = _selectedFolder.Id,
                TargetFolderId = _moveTargetFolderId.Value,
                AssetIds = _selectedAssetIds.ToList()
            };

            await FolderService.MoveFolderAssetsAsync(request);
            _moveAssetsDialogVisible = false;
            await LoadFolderAssets(_selectedFolder.Id);
            await LoadSubFoldersWithThumbnails(_selectedFolder);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error al mover archivos: {ex.Message}", Severity.Error);
        }
    }

    private Task<IEnumerable<int?>> SearchMoveFolderAsync(string value, CancellationToken cancellationToken)
    {
        var query = string.IsNullOrWhiteSpace(value)
            ? _allFolders.AsEnumerable()
            : _allFolders.Where(f =>
                GetDisplayPath(f).Contains(value, StringComparison.OrdinalIgnoreCase) ||
                f.Name.Contains(value, StringComparison.OrdinalIgnoreCase));

        var results = query
            .Where(f => _selectedFolder == null || f.Id != _selectedFolder.Id)
            .OrderBy(f => f.Path)
            .Select(f => (int?)f.Id)
            .ToList();

        return Task.FromResult<IEnumerable<int?>>(results);
    }

    private string MoveFolderToString(int? folderId)
    {
        if (!folderId.HasValue)
        {
            return string.Empty;
        }

        var folder = _allFolders.FirstOrDefault(f => f.Id == folderId.Value);
        return folder == null ? string.Empty : GetDisplayPath(folder);
    }

    private Task<IEnumerable<int?>> SearchEditParentFolderAsync(string value, CancellationToken cancellationToken)
    {
        var query = string.IsNullOrWhiteSpace(value)
            ? GetEditableParentFolders()
            : GetEditableParentFolders().Where(f =>
                GetDisplayPath(f).Contains(value, StringComparison.OrdinalIgnoreCase) ||
                f.Name.Contains(value, StringComparison.OrdinalIgnoreCase));

        var results = query
            .OrderBy(f => f.Path)
            .Select(f => (int?)f.Id)
            .ToList();

        return Task.FromResult<IEnumerable<int?>>(results);
    }

    private string EditParentFolderToString(int? folderId)
    {
        if (!folderId.HasValue)
        {
            return "Inicio";
        }

        var folder = _allFolders.FirstOrDefault(f => f.Id == folderId.Value);
        return folder == null ? string.Empty : GetDisplayPath(folder);
    }

    private IEnumerable<FolderItem> GetEditableParentFolders()
    {
        return _allFolders.Where(f =>
            _selectedFolder == null || f.Id != _selectedFolder.Id)
            .Where(f => !IsUserRootPath(f.Path.Replace('\\', '/')));
    }

    private async Task LoadUserRootAsync()
    {
        var currentUser = await AuthService.GetCurrentUserAsync();
        if (currentUser != null)
        {
            _userId = currentUser.Id;
            _userRootPrefix = $"/assets/users/{currentUser.Id}/";
        }
    }

    private void UpdateUserRootPhysicalPrefix()
    {
        if (_userId == null || !_allFolders.Any())
        {
            return;
        }

        var marker = $"/users/{_userId}/";
        var match = _allFolders
            .Select(f => f.Path.Replace('\\', '/'))
            .FirstOrDefault(p => p.Contains(marker, StringComparison.OrdinalIgnoreCase));

        if (match == null)
        {
            return;
        }

        var index = match.IndexOf(marker, StringComparison.OrdinalIgnoreCase);
        if (index >= 0)
        {
            _userRootPhysicalPrefix = match.Substring(0, index) + marker;
        }
    }

    private void FilterFoldersToUserRoot()
    {
        if (string.IsNullOrEmpty(_userRootPrefix) && string.IsNullOrEmpty(_userRootPhysicalPrefix))
        {
            return;
        }

        bool IsInUserRoot(FolderItem folder)
        {
            var normalized = folder.Path.Replace('\\', '/');
            if (!string.IsNullOrEmpty(_userRootPrefix) &&
                (normalized.Equals(_userRootPrefix.TrimEnd('/'), StringComparison.OrdinalIgnoreCase) ||
                 normalized.StartsWith(_userRootPrefix, StringComparison.OrdinalIgnoreCase)))
            {
                return true;
            }

            if (!string.IsNullOrEmpty(_userRootPhysicalPrefix) &&
                (normalized.Equals(_userRootPhysicalPrefix.TrimEnd('/'), StringComparison.OrdinalIgnoreCase) ||
                 normalized.StartsWith(_userRootPhysicalPrefix, StringComparison.OrdinalIgnoreCase)))
            {
                return true;
            }

            return false;
        }

        List<FolderItem> FilterTree(List<FolderItem> folders)
        {
            var filtered = new List<FolderItem>();
            foreach (var folder in folders)
            {
                if (folder.SubFolders != null && folder.SubFolders.Any())
                {
                    folder.SubFolders = FilterTree(folder.SubFolders);
                }

                if (IsInUserRoot(folder))
                {
                    filtered.Add(folder);
                }
                else if (folder.SubFolders != null && folder.SubFolders.Any())
                {
                    filtered.AddRange(folder.SubFolders);
                }
            }

            return filtered;
        }

        _allFolders = _allFolders.Where(IsInUserRoot).ToList();
        _folderTree = FilterTree(_folderTree);
    }

    private string GetDisplayPath(FolderItem folder)
    {
        var normalized = folder.Path.Replace('\\', '/');
        if (!string.IsNullOrEmpty(_userRootPrefix) &&
            normalized.Equals(_userRootPrefix.TrimEnd('/'), StringComparison.OrdinalIgnoreCase))
        {
            return "Inicio";
        }

        if (!string.IsNullOrEmpty(_userRootPrefix) &&
            normalized.StartsWith(_userRootPrefix, StringComparison.OrdinalIgnoreCase))
        {
            var relative = normalized.Substring(_userRootPrefix.Length).TrimStart('/');
            return string.IsNullOrEmpty(relative) ? "Inicio" : $"Inicio/{relative}";
        }

        if (!string.IsNullOrEmpty(_userRootPhysicalPrefix) &&
            normalized.StartsWith(_userRootPhysicalPrefix, StringComparison.OrdinalIgnoreCase))
        {
            var relative = normalized.Substring(_userRootPhysicalPrefix.Length).TrimStart('/');
            return string.IsNullOrEmpty(relative) ? "Inicio" : $"Inicio/{relative}";
        }

        return folder.Path;
    }

    private string GetDisplayFolderName(FolderItem folder)
    {
        var normalized = folder.Path.Replace('\\', '/');
        if (IsUserRootPath(normalized))
        {
            return "Inicio";
        }

        return folder.Name;
    }

    private bool IsUserRootPath(string normalizedPath)
    {
        if (!string.IsNullOrEmpty(_userRootPrefix) &&
            normalizedPath.Equals(_userRootPrefix.TrimEnd('/'), StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        if (!string.IsNullOrEmpty(_userRootPhysicalPrefix) &&
            normalizedPath.Equals(_userRootPhysicalPrefix.TrimEnd('/'), StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        return false;
    }
}
